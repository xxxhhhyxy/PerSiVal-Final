using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class FaceVisualizer : MonoBehaviour
{
    /// <summary>
    /// whether is initialization is complete
    /// </summary>
    bool isInited = false;
    /// <summary>
    /// whether to swith on/off the rendering
    /// </summary>
    bool isRendered = false;
    /// <summary>
    /// the pre-defined parent of the biceps I render, just keep it
    /// </summary>
    public GameObject bicepsParent;
    /// <summary>
    /// the carrier of the mesh I create by codes
    /// </summary>
    [HideInInspector]
    public GameObject bicepsObj;
    private MeshFilter meshFilter;
    private Mesh mesh;
    private MeshRenderer meshRender;

    #region the bought model, to visualiza the arm bones
    /// <summary>
    /// the parent of the bought upper arm model, make it convenient to rotate it later
    /// </summary>
    public GameObject UpperArmParent;
    /// <summary>
    /// the core of the bought upper arm model
    /// </summary>
    public GameObject UpperArmCore;
    /// <summary>
    /// the shoulder pos on the upper arm
    /// </summary>
    public GameObject UpperArmShoulder;
    /// <summary>
    /// the elbow pos on the upper arm
    /// </summary>
    public GameObject UpperArmElbow;
    public GameObject LowerArmParent;
    public GameObject LowerArmElbow;
    public GameObject LowerArmWrist;
    /// <summary>
    /// the tendon pos on the lower arm
    /// </summary>
    public GameObject LowerTendon;
    /// <summary>
    /// the original length of the bought upper arm model
    /// </summary>
    private float upperArmLength;
    /// <summary>
    /// the original length of the bought lower arm model
    /// </summary>
    private float lowerArmLength;
    #endregion

    #region debugging visualizazion
    /// <summary>
    /// the X axis of the biceps gameobject
    /// </summary>
    public GameObject coordX;
    public GameObject coordY;
    public GameObject coordZ;
    /// <summary>
    /// the visualization of the upper end of the biceps mesh
    /// </summary>
    public GameObject upper;
    /// <summary>
    /// the visualization of the lower end of the biceps mesh
    /// </summary>
    public GameObject lower;
    #endregion

    /// <summary>
    /// a vector generated by the 2 vertices on the lowest end of the biceps
    /// </summary>
    private Vector3 basicVec;
    /// <summary>
    /// where the lower arm is pointing at? projected on the upperarm
    /// </summary>
    private Vector3 lowerOrVec;
    /// <summary>
    /// the offset between the biceps shoulder vertice and the origin of the biceps gameobject
    /// </summary>
    private Vector3 offset;
    // Start is called before the first frame update


    public void f_Init()
    {
        upperArmLength= Vector3.Distance(UpperArmElbow.transform.position, UpperArmShoulder.transform.position);
        lowerArmLength= Vector3.Distance(LowerArmElbow.transform.position, LowerArmWrist.transform.position);
        LowerArmParent.gameObject.SetActive(true);
        UpperArmParent.gameObject.SetActive(true);
        bicepsObj = new GameObject("Biceps");
        bicepsObj.transform.SetParent(bicepsParent.transform);
        //bicepsObj.transform.localPosition = new Vector3(-0.1f,-0.15f,0.3f);
        meshFilter = bicepsObj.AddComponent<MeshFilter>();
        meshRender = bicepsObj.AddComponent<MeshRenderer>();
        mesh = meshFilter.mesh;
        meshRender.sharedMaterial = GlobalCtrl.M_Instance.Mat_Biceps;
        Debug.Log("Face Initialization");
        #region initialization of debugging visualization
        upper.transform.SetParent(bicepsObj.transform);
        lower.transform.SetParent(bicepsObj.transform);
        coordX.transform.SetParent(bicepsObj.transform);
        coordY.transform.SetParent(bicepsObj.transform);
        coordZ.transform.SetParent(bicepsObj.transform);
        coordX.transform.localPosition = new Vector3(0.05f, 0, 0);
        coordY.transform.localPosition = new Vector3(0, 0.05f, 0);
        coordZ.transform.localPosition = new Vector3( 0, 0, 0.05f);
        #endregion
        isInited = true;
    }
    public void ChangeStatus(bool isOn)
    {
        isRendered = isOn;
        if (isOn && !isInited)
            f_Init();
    }
    // Update is called once per frame
    public void UpdateVisualizer()
    {
        if (!isInited)
            return;
        if (!GlobalCtrl.M_Instance.M_HumanBodyTracker.isTracked)
            return;
        if (!isRendered)
            return;

        mesh.vertices = GlobalCtrl.M_MeshCtrl.M_Vertices;
        mesh.triangles = GlobalCtrl.M_MeshCtrl.M_Triangles;
        mesh.SetNormals(GlobalCtrl.M_MeshCtrl.M_Normals);


        //bicepsParent.transform.localScale = Vector3.one * GlobalCtrl.M_Instance.LS2E.magnitude / NNOriLength;
        //bicepsParent.transform.position = GlobalCtrl.M_Instance.LShoulder;
        //bicepsParent.transform.LookAt(GlobalCtrl.M_Instance.LShoulder - 100 * GlobalCtrl.M_Instance.LS2E, Vector3.Project(GlobalCtrl.M_Instance.LE2W, GlobalCtrl.M_Instance.LS2E));


        bicepsObj.transform.position = Vector3.zero;
        bicepsObj.transform.rotation = Quaternion.identity;
        GameObject upperEnd = new GameObject("UpperEnd");
        upperEnd.transform.SetParent(bicepsObj.transform);
        upperEnd.transform.position = GlobalCtrl.M_MeshCtrl.M_Vertices[27];    
        upper.transform.position = upperEnd.transform.position;
        GameObject lowerEnd = new GameObject("lowerEnd");
        lowerEnd.transform.SetParent(bicepsObj.transform);
        lowerEnd.transform.position = (GlobalCtrl.M_MeshCtrl.M_Vertices[68]+ GlobalCtrl.M_MeshCtrl.M_Vertices[387])/2;
        lower.transform.position = lowerEnd.transform.position;
        float modelLength = Vector3.Distance(upperEnd.transform.position, lowerEnd.transform.position);
        float ratio = GlobalCtrl.M_Instance.LS2E.magnitude / modelLength;
        bicepsObj.transform.localScale = Vector3.one * ratio;

        Quaternion a = Quaternion.FromToRotation(lowerEnd.transform.position - upperEnd.transform.position, LowerTendon.transform.position - GlobalCtrl.M_Instance.LShoulder);
        bicepsObj.transform.rotation = a;

        offset = ratio * upperEnd.transform.position - bicepsObj.transform.position;
        bicepsObj.transform.position = GlobalCtrl.M_Instance.LShoulder - offset;
        //bicepsObj.transform.RotateAround(GlobalCtrl.M_Instance.LShoulder,GlobalCtrl.M_Instance.LS2E,180);
        //bicepsObj.transform.LookAt(bicepsObj.transform.position+100*Vector3.Project(GlobalCtrl.M_Instance.LE2W, GlobalCtrl.M_Instance.LS2E));

        basicVec =Vector3.ProjectOnPlane( GlobalCtrl.M_MeshCtrl.M_Vertices[387] - GlobalCtrl.M_MeshCtrl.M_Vertices[68],GlobalCtrl.M_Instance.LS2E);
        lowerOrVec= Vector3.Project(GlobalCtrl.M_Instance.LE2W, GlobalCtrl.M_Instance.LS2E);
        //bicepsObj.transform.rotation *= Quaternion.FromToRotation(basicVec,lowerOrVec);
        bicepsObj.transform.RotateAround(GlobalCtrl.M_Instance.LShoulder, GlobalCtrl.M_Instance.LS2E, Vector3.Angle(basicVec,lowerOrVec)+GlobalCtrl.M_UIManager.sli_angle.value); ;

        
        UpperArmParent.transform.position = (GlobalCtrl.M_Instance.LShoulder + GlobalCtrl.M_Instance.LElbow) / 2;
        UpperArmParent.transform.localScale = GlobalCtrl.M_Instance.LS2E.magnitude / upperArmLength * Vector3.one;
        UpperArmParent.transform.LookAt(GlobalCtrl.M_Instance.LElbow, Vector3.Project(GlobalCtrl.M_Instance.LE2W, GlobalCtrl.M_Instance.LS2E));

        LowerArmParent.transform.position = GlobalCtrl.M_Instance.LElbow;
        LowerArmParent.transform.localScale = GlobalCtrl.M_Instance.LE2W.magnitude / lowerArmLength * Vector3.one;
        LowerArmParent.transform.LookAt(GlobalCtrl.M_Instance.LWrist);
        

        /*
        UpperArmParent.transform.position = Vector3.zero;
        UpperArmParent.transform.rotation = Quaternion.identity;
        UpperArmParent.transform.rotation = Quaternion.FromToRotation(UpperArmElbow.transform.position - UpperArmShoulder.transform.position, GlobalCtrl.M_Instance.LElbow - GlobalCtrl.M_Instance.LShoulder);
        float upperRatio = GlobalCtrl.M_Instance.LS2E.magnitude / upperArmLength;
        UpperArmParent.transform.localScale =upperRatio * Vector3.one;
        UpperArmParent.transform.position = GlobalCtrl.M_Instance.LShoulder - upperRatio * UpperArmShoulder.transform.position - UpperArmParent.transform.position;

        LowerArmParent.transform.position = Vector3.zero;
        LowerArmParent.transform.rotation = Quaternion.identity;
        LowerArmParent.transform.rotation = Quaternion.FromToRotation(LowerArmWrist.transform.position - LowerArmElbow.transform.position, GlobalCtrl.M_Instance.LWrist - GlobalCtrl.M_Instance.LElbow);
        float lowerRatio = GlobalCtrl.M_Instance.LE2W.magnitude / lowerArmLength;
        LowerArmParent.transform.localScale = lowerRatio * Vector3.one;
        LowerArmParent.transform.position = GlobalCtrl.M_Instance.LElbow - lowerRatio * LowerArmElbow.transform.position - LowerArmParent.transform.position;
        */
        }
}
